#-*- coding: utf8 -*-
import os
from base64 import b64encode

import pytest
import time

from server.api.modules.vulns import VulnerabilityView
from test_cases import factories
from test_api_workspaced_base import (
    ReadOnlyAPITests
)
from server.models import (
    Vulnerability,
    VulnerabilityWeb,
    Reference, PolicyViolation, CommandObject)
from test_cases.factories import ServiceFactory, CommandFactory, CommandObjectFactory, HostFactory, EmptyCommandFactory, \
    UserFactory, VulnerabilityWebFactory

CURRENT_PATH = os.path.dirname(os.path.abspath(__file__))


@pytest.mark.usefixtures('logged_user')
class TestListVulnerabilityView(ReadOnlyAPITests):  # TODO migration: use read write api tests
    model = Vulnerability
    factory = factories.VulnerabilityFactory
    api_endpoint = 'vulns'
    #unique_fields = ['ip']
    #update_fields = ['ip', 'description', 'os']
    view_class = VulnerabilityView

    def test_backward_json_compatibility(self, test_client, second_workspace, session):
        self.factory.create(workspace=second_workspace)
        session.commit()
        res = test_client.get(self.url())
        assert res.status_code == 200
        assert 'vulnerabilities' in res.json
        for vuln in res.json['vulnerabilities']:
            assert set([u'id', u'key', u'value']) == set(vuln.keys())
            object_properties = [
                u'status',
                u'issuetracker',
                u'description',
                u'parent',
                u'tags',
                u'severity',
                u'_rev',
                u'easeofresolution',
                u'owned',
                u'hostnames',
                u'pname',
                u'query',
                u'owner',
                u'path',
                u'data',
                u'response',
                u'refs',
                u'desc',
                u'impact',
                u'confirmed',
                u'name',
                u'service',
                u'obj_id',
                u'type',
                u'policyviolations',
                u'request',
                u'_attachments',
                u'target',
                u'_id',
                u'resolution',
                u'method',
                u'metadata',
                u'website',
                u'params',
            ]
            expected = set(object_properties)
            result = set(vuln['value'].keys())
            assert expected - result == set()

    def test_handles_vuln_with_no_creator(self,
                                          workspace,
                                          test_client,
                                          session):
        # This can happen when a user is deleted but its objects persist
        vuln = self.factory.create(workspace=workspace, creator=None)
        session.commit()
        res = test_client.get(self.url(vuln))
        assert res.status_code == 200
        assert res.json['owner'] is None

    def test_shows_policy_violations(self, workspace, test_client, session,
                                     policy_violation_factory):
        pvs = policy_violation_factory.create_batch(
            5, workspace=workspace)
        for pv in pvs:
            self.first_object.policy_violation_instances.add(pv)
        session.commit()
        res = test_client.get(self.url(self.first_object))
        assert res.status_code == 200
        assert len(res.json['policyviolations']) == 5
        assert set(res.json['policyviolations']) == {pv.name for pv in pvs}

    def test_shows_refs(self, workspace, test_client, session,
                        reference_factory):
        refs = reference_factory.create_batch(
            5, workspace=workspace)
        for ref in refs:
            self.first_object.reference_instances.add(ref)
        session.commit()
        res = test_client.get(self.url(self.first_object))
        assert res.status_code == 200
        assert len(res.json['refs']) == 5
        assert set(res.json['refs']) == {ref.name for ref in refs}

    @pytest.mark.parametrize('creator_func', [
        (lambda host: factories.VulnerabilityFactory.create(
            workspace=host.workspace, host=host, service=None)),
        (lambda host: factories.VulnerabilityFactory.create(
            workspace=host.workspace, host=None,
            service=factories.ServiceFactory.create(
                workspace=host.workspace, host=host
            ))),
        (lambda host: factories.VulnerabilityWebFactory.create(
            workspace=host.workspace, service=factories.ServiceFactory.create(
                workspace=host.workspace, host=host
            ))),
    ], ids=['standard_vuln_with_host', 'standard_vuln_with_service',
            'web_vuln_with_service'])
    def test_hostnames(self, host_with_hostnames, test_client, session,
                       creator_func):
        vuln = creator_func(host_with_hostnames)
        vuln = self.factory.create(host=host_with_hostnames,
                                   service=None,
                                   workspace=host_with_hostnames.workspace)
        session.commit()
        res = test_client.get(self.url(vuln))
        assert res.status_code == 200
        assert isinstance(res.json['hostnames'], list)
        assert set(res.json['hostnames']) == set(hostname.name for hostname in
                                                 host_with_hostnames.hostnames)

    def _create_post_data_vulnerability(self, name, vuln_type, parent_id,
                                        parent_type, refs, policyviolations,
                                        status='opened',
                                        attachments=None, impact=None, description='desc1234',
                                        confirmed=True, data='data1234', easeofresolution=Vulnerability.EASE_OF_RESOLUTIONS[0],
                                        owned=False, resolution='res1234', severity='critical'):
        if not impact:
            impact = {'accountability': False, 'availability': False, 'confidentiality': False,
                           'integrity': False}
        data = {'metadata': {'update_time': 1508254070.211, 'update_user': '', 'update_action': 0, 'creator': 'UI Web',
                             'create_time': 1508254070.211, 'update_controller_action': 'UI Web New', 'owner': ''},
                'obj_id': '5a60af7f01dde6d3acfa8e9d3bef265c361a49d2',
                'owner': '',
                'parent': parent_id,
                'parent_type': parent_type,
                'type': vuln_type,
                'ws': 'airbnb',
                'confirmed': confirmed,
                'data': data,
                'desc': description,
                'easeofresolution': easeofresolution,
                'impact': impact,
                'name': name,
                'owned': owned,
                'policyviolations': policyviolations,
                'refs': refs,
                'resolution': resolution,
                'severity': severity,
                'status': status,
                '_attachments': {},
                'description': '',
                'protocol': '',
                'version': ''}

        if vuln_type == 'VulnerabilityWeb':
            data.update({
                "method": "GET",
                "params": "pepe",
                "path": "/pepep",
                "pname": "pepe",
                "query": "queue&dfsa",
                "request": "",
                "response": "",
                "website": "www.pepe.com"})

        if attachments:
            data['_attachments'] = {}
            for attachment in attachments:
                 data['_attachments'][attachment.name] = {
                     "content_type": "application/x-shellscript",
                     "data": b64encode(attachment.read())
                 }

        return data

    def test_create_vuln(self, host_with_hostnames, test_client, session):
        """
        This one should only check basic vuln properties
        :param host_with_hostnames:
        :param test_client:
        :param session:
        :return:
        """
        session.commit()  # flush host_with_hostnames
        raw_data = self._create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='low',
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        assert vuln_count_previous + 1 == session.query(Vulnerability).count()
        assert res.json['name'] == 'New vulns'
        assert res.json['type'] == 'Vulnerability'
        assert res.json['parent'] == host_with_hostnames.id
        assert res.json['parent_type'] == 'Host'
        assert res.json['desc'] == 'helloworld'
        assert res.json['description'] == 'helloworld'
        assert res.json['severity'] == 'low'

    def test_create_vuln_props(self, host_with_hostnames, test_client, session):
        """
        This one should check all the vuln props that don't have a specific case
        :param host_with_hostnames:
        :param test_client:
        :param session:
        :return:
        """
        session.commit()  # flush host_with_hostnames
        vuln_props = {
            'confirmed': False,
            'data': 'hellodata',
            'easeofresolution': Vulnerability.EASE_OF_RESOLUTIONS[0],
            'owned': True,
            'resolution': 'helloresolution',
            'status': 'closed'
        }
        vuln_props_excluded = ['owned']
        raw_data = self._create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='low',
            **vuln_props
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        for prop, value in vuln_props.iteritems():
            if prop not in vuln_props_excluded:
                assert res.json[prop] == value, prop

    @pytest.mark.skip(reason="Known bug")
    def test_create_idempotent(self, host_with_hostnames, test_client, session):
        """
        This test makes sure that creating the same vuln twice doesn't duplicate the entry or has any other collateral effects
        :param host_with_hostnames:
        :param test_client:
        :param session:
        :return:
        """
        session.commit()  # flush host_with_hostnames
        raw_data = self._create_post_data_vulnerability(
            name='Vulnerability name goes here',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='Description goes here',
            severity='critical',
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        assert vuln_count_previous + 1 == session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 400
        assert vuln_count_previous + 1 == session.query(Vulnerability).count()


    def test_create_vuln_with_closed_status(self, host_with_hostnames, test_client, session):
        session.commit()  # flush host_with_hostnames
        raw_data = self._create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            status='closed',
            refs=[],
            policyviolations=[]
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        assert vuln_count_previous + 1 == session.query(Vulnerability).count()
        assert res.json['status'] == 'closed'
        assert res.json['name'] == 'New vulns'
        assert res.json['type'] == 'Vulnerability'
        assert res.json['parent'] == host_with_hostnames.id
        assert res.json['parent_type'] == 'Host'

    def test_create_vuln_with_closed_status(self, host_with_hostnames, test_client, session):
        session.commit()  # flush host_with_hostnames
        raw_data = self._create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            status='closed',
            refs=[],
            policyviolations=[]
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        assert vuln_count_previous + 1 == session.query(Vulnerability).count()
        assert res.json['status'] == 'closed'
        assert res.json['name'] == 'New vulns'
        assert res.json['type'] == 'Vulnerability'
        assert res.json['parent'] == host_with_hostnames.id
        assert res.json['parent_type'] == 'Host'

    def _create_put_data(self,
                         name, desc, status, parent, parent_type,
                         impact=None, refs=None, policy_violations=None):
        if not refs:
            refs = []
        if not policy_violations:
            policy_violations = []

        if not impact:
            impact = {"accountability": False, "availability": False, "confidentiality": False, "integrity": False}

        raw_data = {
            "_id":"e1b45f5375facfb1435d37e182ebc22de5f77bb3.e05df1c85617fffb575d2ced2679e9a0ebda7c3e",
            "metadata":{
                "update_time":1509045001.279,
                "update_user":"",
                "update_action":0,
                "creator":"UI Web",
                "create_time":1509045001.279,
                "update_controller_action":
                    "UI Web New",
                "owner":""},
            "obj_id":"e05df1c85617fffb575d2ced2679e9a0ebda7c3e",
            "owner":"",
            "parent": parent,
            "type":"Vulnerability",
            "ws":"cloud",
            "confirmed": True,
            "data":"",
            "desc": desc,
            "easeofresolution":"",
            "impact": impact,
            "name": name,
            "owned": False,
            "policyviolations":policy_violations,
            "refs": refs,
            "resolution":"",
            "severity": "critical",
            "status": status,
            "_attachments":{},
            "description":"",
            "parent_type": parent_type,
            "protocol":"",
            "version":""}

        return raw_data

    @pytest.mark.skip(reason="Update not yet implemented")
    def test_update_vuln_from_open_to_close(self, test_client, session, host_with_hostnames):
        vuln = self.factory.create(status='open', host=host_with_hostnames, service=None, workspace=host_with_hostnames.workspace)
        session.commit()
        raw_data = self._create_put_data(
            name='New name',
            desc='New desc',
            status='closed',
            parent=vuln.host.id,
            parent_type='Host',
            refs=['ref1'],
            policy_violations=['pv0']
        )
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.put(self.url(vuln), data=raw_data)
        assert res.status_code == 200
        assert vuln_count_previous == session.query(Vulnerability).count()
        assert res.json['status'] == 'closed'
        assert res.json['name'] == 'New name'
        assert res.json['desc'] == 'New desc'

    def test_create_vuln_web(self, host_with_hostnames, test_client, session):
        service = ServiceFactory.create(host=host_with_hostnames, workspace=host_with_hostnames.workspace)
        session.commit()  # flush host_with_hostnames
        raw_data = self._create_post_data_vulnerability(
            name='New vulns',
            vuln_type='VulnerabilityWeb',
            parent_id=service.id,
            parent_type='Service',
            refs=[],
            policyviolations=[]
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        vuln_web_count_previous = session.query(VulnerabilityWeb).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        assert vuln_web_count_previous + 1 == session.query(VulnerabilityWeb).count()
        assert vuln_count_previous  == session.query(Vulnerability).count()
        assert res.json['name'] == 'New vulns'
        assert res.json['owner'] == 'test'
        assert res.json['type'] == 'VulnerabilityWeb'
        assert res.json['parent'] == service.id
        assert res.json['parent_type'] == 'Service'
        assert res.json['method'] == 'GET'
        assert res.json['path'] == '/pepep'

    @pytest.mark.usefixtures('mock_envelope_list')
    def test_filter_by_severity(self, test_client, session,
                                second_workspace,
                                vulnerability_factory,
                                vulnerability_web_factory,
                                ):
        expected_ids = set()

        high_vulns = vulnerability_factory.create_batch(
            5, workspace=second_workspace, severity='high')
        high_vulns_web = vulnerability_web_factory.create_batch(
            5, workspace=second_workspace, severity='high')
        session.commit()

        expected_ids.update(vuln.id for vuln in high_vulns)
        expected_ids.update(vuln.id for vuln in high_vulns_web)

        vulnerability_factory.create_batch(
            5, workspace=second_workspace, severity='medium')
        vulnerability_web_factory.create_batch(
            5, workspace=second_workspace, severity='medium')

        res = test_client.get(self.url(
            workspace=second_workspace) + '?severity=high')
        assert res.status_code == 200
        for vuln in res.json['data']:
            assert vuln['severity'] == 'high'
        assert set(vuln['_id'] for vuln in res.json['data']) == expected_ids

    @pytest.mark.usefixtures('mock_envelope_list')
    def test_filter_by_invalid_severity(self, test_client):
        res = test_client.get(self.url() + '?severity=invalid')
        assert res.status_code == 400

    @pytest.mark.usefixtures('mock_envelope_list')
    def test_filter_by_method(self, test_client, session, second_workspace,
                              vulnerability_factory,
                              vulnerability_web_factory):

        # Vulns that shouldn't be shown
        vulnerability_factory.create_batch(5, workspace=second_workspace)
        vulnerability_web_factory.create_batch(5, workspace=second_workspace,
                                               method='POSTT')

        # Vulns that must be shown
        expected_vulns = vulnerability_web_factory.create_batch(
            5, workspace=second_workspace, method='POST')

        session.commit()
        expected_ids = {vuln.id for vuln in expected_vulns}

        # This shouldn't show any vulns with POSTT method
        res = test_client.get(self.url(
            workspace=second_workspace) + '?method=POST')
        assert res.status_code == 200
        assert set(vuln['_id'] for vuln in res.json['data']) == expected_ids

        # This shouldn't show any vulns since by default method filter is
        # an exact match, not a like statement
        res = test_client.get(self.url(
            workspace=second_workspace) + '?method=%25POST%25')
        assert res.status_code == 200
        assert len(res.json['data']) == 0

    @pytest.mark.usefixtures('mock_envelope_list')
    def test_filter_by_website(self, test_client, session,
                               second_workspace,
                               vulnerability_factory,
                               vulnerability_web_factory,
                               ):

        # Vulns that shouldn't be shown
        vulnerability_factory.create_batch(5, workspace=second_workspace)
        vulnerability_web_factory.create_batch(
            5, workspace=second_workspace, website='other.com')

        # Vulns that must be shown
        expected_vulns = vulnerability_web_factory.create_batch(
            5, workspace=second_workspace, website='faradaysec.com')
        session.commit()
        expected_ids = {vuln.id for vuln in expected_vulns}

        res = test_client.get(self.url(
            workspace=second_workspace) + '?website=faradaysec.com')
        assert res.status_code == 200

        for vuln in res.json['data']:
            assert vuln['website'] == 'faradaysec.com'
        assert set(vuln['_id'] for vuln in res.json['data']) == expected_ids

    def test_create_vuln_with_evidence(self, host_with_hostnames, test_client, session):
        session.commit()  # flush host_with_hostnames
        attachments = [
            open(os.path.join(CURRENT_PATH, 'data', 'faraday.png'), 'r'),
            open(os.path.join(CURRENT_PATH, 'data', 'test.html'), 'r')
        ]
        raw_data = self._create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            attachments=attachments,
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)

        assert res.status_code == 201
        assert len(res.json['_attachments']) == 2
        assert vuln_count_previous + 1 == session.query(Vulnerability).count()
        map(lambda fileobj: fileobj.close(), attachments)

    def test_create_vuln_with_refs(self, host_with_hostnames, test_client, session):
        session.commit()  # flush host_with_hostnames
        raw_data = self._create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=['CVE-2017-0002', 'CVE-2017-0012', 'CVE-2017-0012'],
            policyviolations=[]
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        assert session.query(Reference).count() == 2
        assert vuln_count_previous + 1 == session.query(Vulnerability).count()

    def test_create_vuln_with_policyviolations(self, host_with_hostnames, test_client, session):
        session.commit()  # flush host_with_hostnames
        raw_data = self._create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=['PCI DSS Credir card not encrypted',
                              'PCI DSS Credir card not encrypted'],
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        assert session.query(PolicyViolation).count() == 1
        assert vuln_count_previous + 1 == session.query(Vulnerability).count()

    def test_create_vuln_imapct_verification(self, host_with_hostnames, test_client, session):
        session.commit()  # flush host_with_hostnames
        raw_data = self._create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            impact={
                'accountability': True,
                'availability': True,
                'confidentiality': True,
                'integrity': True
            }
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        assert vuln_count_previous + 1 == session.query(Vulnerability).count()
        assert res.json['name'] == 'New vulns'
        assert res.json['impact'] == {u'accountability': True,
                                     u'availability': True,
                                     u'confidentiality': True,
                                     u'integrity': True}

    def test_handles_invalid_impact(self, host_with_hostnames, test_client,
                                    session):
        session.commit()  # flush host_with_hostnames
        raw_data = self._create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            impact={
                'accountability': True,
                'integrity': 'aaaa',
                'invalid': None,
            }
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 400

    def test_create_vuln_with_invalid_type(self,
                                           host_with_hostnames,
                                           test_client,
                                           session):
        session.commit()  # flush host_with_hostnames
        raw_data = self._create_post_data_vulnerability(
            name='New vulns',
            vuln_type='VulnerabilitySarasa',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[]
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post(
            '/v2/ws/{0}/vulns/'.format(ws_name),
            data=raw_data,
        )
        assert res.status_code == 400
        assert vuln_count_previous == session.query(Vulnerability).count()
        assert res.json['message'] == 'Invalid vulnerability type.'

    def test_create_vuln_with_invalid_ease_of_resolution(self,
                                                         host_with_hostnames,
                                                         test_client,
                                                         session):
        session.commit()  # flush host_with_hostnames
        raw_data = self._create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            easeofresolution='frutafrutafruta'
        )
        ws_name = host_with_hostnames.workspace.name
        vuln_count_previous = session.query(Vulnerability).count()
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 400
        assert vuln_count_previous == session.query(Vulnerability).count()
        assert res.json['messages'].keys() == ['easeofresolution']
        assert res.json['messages']['easeofresolution'][0] == u'Not a valid choice.'

    def test_count_confirmed(self, test_client, session):
        for i, vuln in enumerate(self.objects[:3]):
            vuln.confirmed = True

            # Set critical severity to first vuln, high to the others
            if i == 0:
                vuln.severity = 'critical'
            else:
                vuln.severity = 'high'

            session.add(vuln)
            session.commit()

        res = test_client.get(self.url() +
                              'count/?confirmed=1&group_by=severity')
        assert res.status_code == 200
        assert res.json['total_count'] == 3
        assert sorted(res.json['groups']) == sorted([
            {"name": "high", "severity": "high", "count": 2},
            {"name": "critical", "severity": "critical", "count": 1},
        ])

    def test_count_severity_map(self, test_client, second_workspace, session):
        self.factory.create_batch(4, severity='informational',
                                  workspace=second_workspace)
        self.factory.create_batch(3, severity='medium',
                                  workspace=second_workspace)
        self.factory.create_batch(2, severity='low',
                                  workspace=second_workspace)
        session.commit()

        res = test_client.get(self.url(workspace=second_workspace) +
                              'count/?group_by=severity')
        assert res.status_code == 200
        assert res.json['total_count'] == 9
        assert sorted(res.json['groups']) == sorted([
            {"name": "med", "severity": "med", "count": 3},
            {"name": "low", "severity": "low", "count": 2},
            {"name": "info", "severity": "info", "count": 4},
        ])

    @pytest.mark.usefixtures('mock_envelope_list')
    def test_target(self, test_client, session, second_workspace,
                    host_factory, service_factory,
                    vulnerability_factory, vulnerability_web_factory):
        host = host_factory.create(workspace=second_workspace)
        service = service_factory.create(host=host,
                                         workspace=second_workspace)
        vulns = [
            vulnerability_factory.create(host=host, service=None,
                                         workspace=second_workspace),
            vulnerability_factory.create(service=service, host=None,
                                         workspace=second_workspace),
            vulnerability_web_factory.create(service=service,
                                             workspace=second_workspace),
        ]

        res = test_client.get(self.url(workspace=second_workspace))
        assert res.status_code == 200
        for v in res.json['data']:
            assert v['target'] == host.ip

    @pytest.mark.usefixtures('mock_envelope_list')
    @pytest.mark.usefixtures('ignore_nplusone')
    def test_filter_by_command_id(self, test_client, session,
                                  second_workspace,
                                  workspace,
                                  vulnerability_factory,
                                  vulnerability_web_factory,
                                  ):
        expected_ids = set()
        web_expected_ids = set()
        host = HostFactory.create(workspace=second_workspace)
        service = ServiceFactory.create(workspace=second_workspace)

        command = EmptyCommandFactory.create(workspace=second_workspace)
        web_command = EmptyCommandFactory.create(workspace=second_workspace)
        high_vulns = vulnerability_factory.create_batch(
            5, workspace=second_workspace, severity='high', host=host, service=None)
        high_vulns_web = vulnerability_web_factory.create_batch(
            5, workspace=second_workspace, severity='high', service=service)
        session.commit()
        CommandObjectFactory.create(
            command=command,
            object_type='host',
            object_id=host.id,
            workspace=second_workspace
        )
        CommandObjectFactory.create(
            command=web_command,
            object_type='service',
            object_id=service.id,
            workspace=second_workspace
        )
        for high_vuln in high_vulns:

            CommandObjectFactory.create(
                command=command,
                object_type='vulnerability',
                object_id=high_vuln.id,
                workspace=second_workspace
            )
        for high_vuln_web in high_vulns_web:

            CommandObjectFactory.create(
                command=web_command,
                object_type='vulnerability',
                object_id=high_vuln_web.id,
                workspace=second_workspace
            )

        session.commit()

        expected_ids.update(vuln.id for vuln in high_vulns)
        web_expected_ids.update(vuln.id for vuln in high_vulns_web)

        res = test_client.get(self.url(
            workspace=second_workspace) + '?command_id={0}'.format(command.id))
        assert res.status_code == 200
        for vuln in res.json['data']:
            command_object = CommandObject.query.filter_by(
                object_id=vuln['_id'],
                object_type='vulnerability',
                workspace=second_workspace,
            ).first()
            vuln['metadata']['command_id'] == command_object.command.id
        assert set(vuln['_id'] for vuln in res.json['data']) == expected_ids

        # Check for web vulns
        res = test_client.get(self.url(
            workspace=second_workspace) + '?command_id={0}'.format(web_command.id))
        assert res.status_code == 200
        for vuln in res.json['data']:
            command_object = CommandObject.query.filter_by(
                object_id=vuln['_id'],
                object_type='vulnerability',
                workspace=second_workspace,
            ).first()
            vuln['metadata']['command_id'] == command_object.command.id
        assert set(vuln['_id'] for vuln in res.json['data']) == web_expected_ids

        # Check for cross-workspace bugs
        res = test_client.get(self.url(
            workspace=workspace) + '?command_id={0}'.format(web_command.id))
        assert res.status_code == 200
        assert len(res.json['data']) == 0

    def test_vulnerability_metadata(self, session, test_client, workspace):
        owner = UserFactory.create()
        service = ServiceFactory.create(workspace=workspace)
        command = EmptyCommandFactory.create(id=5555, workspace=workspace)

        vuln = VulnerabilityWebFactory.create(
            service=service,
            creator=owner,
            workspace=workspace
        )
        session.flush()
        CommandObjectFactory.create(
            command=command,
            object_type='vulnerability',
            object_id=vuln.id,
            workspace=workspace
        )

        res = test_client.get(self.url())
        assert res.status_code == 200
        from_json_vuln = filter(lambda raw_vuln: raw_vuln['id'] == vuln.id,
                                res.json['vulnerabilities'])
        assert 'metadata' in from_json_vuln[0]['value']
        expected_metadata = {
            u'command_id': 5555,
            u'create_time': int(time.mktime(vuln.create_date.timetuple()) * 1000),
            u'creator': u'',
            u'owner': owner.username,
            u'update_action': 0,
            u'update_controller_action': u'',
            u'update_time': int(time.mktime(vuln.update_date.timetuple()) * 1000),
            u'update_user': u''
        }

        assert expected_metadata == from_json_vuln[0]['value']['metadata']

    @pytest.mark.parametrize("parent_type, parent_factory", [
        ("Host", HostFactory),
        ("Service", ServiceFactory),
    ], ids=["with host parent", "with service parent"])
    def test_create_with_parent_of_other_workspace(
            self, parent_type, parent_factory, test_client, session,
            second_workspace):
        parent = parent_factory.create(workspace=second_workspace)
        session.commit()
        assert parent.workspace_id != self.workspace.id
        data = self._create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=parent.id,
            parent_type=parent_type,
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='low',
        )
        res = test_client.post(self.url(), data=data)
        assert res.status_code == 400
        assert 'Parent id not found' in res.data

    @pytest.mark.skip(reason="Update not implemented yet. Also it won't work "
                      "instantly because it is a copy paste of other test. "
                      "It should be changed")
    @pytest.mark.parametrize("parent_type, parent_factory", [
        ("Host", HostFactory),
        ("Service", ServiceFactory),
    ], ids=["with host parent", "with service parent"])
    def test_update_with_parent_of_other_workspace(
            self, parent_type, parent_factory, test_client, session,
            second_workspace, credential_factory):
        parent = parent_factory.create(workspace=second_workspace)
        if parent_type == 'Host':
            credential = credential_factory.create(
                host=HostFactory.create(workspace=self.workspace),
                service=None,
                workspace=self.workspace)
        else:
            credential = credential_factory.create(
                host=None,
                service=ServiceFactory.create(workspace=self.workspace),
                workspace=self.workspace)
        session.commit()
        assert parent.workspace_id != self.workspace.id
        data = {
            "username": "admin",
            "password": "admin",
            "name": "test",
            "parent_type": parent_type,
            "parent": parent.id
        }
        res = test_client.put(self.url(credential), data=data)
        assert res.status_code == 400
        assert 'Parent id not found' in res.data

    def test_create_vuln_multiple_times_returns_conflict(self, host_with_hostnames, test_client, session):
        """
        This one should only check basic vuln properties
        :param host_with_hostnames:
        :param test_client:
        :param session:
        :return:
        """
        session.commit()  # flush host_with_hostnames
        raw_data = self._create_post_data_vulnerability(
            name='New vulns',
            vuln_type='Vulnerability',
            parent_id=host_with_hostnames.id,
            parent_type='Host',
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='low',
        )
        ws_name = host_with_hostnames.workspace.name
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name),
                               data=raw_data)
        assert res.status_code == 409

    def test_create_webvuln_multiple_times_returns_conflict(self, host_with_hostnames, test_client, session):
        """
        This one should only check basic vuln properties
        :param host_with_hostnames:
        :param test_client:
        :param session:
        :return:
        """
        service = ServiceFactory.create(workspace=self.workspace)
        session.commit()  # flush host_with_hostnames
        raw_data = self._create_post_data_vulnerability(
            name='New vulnsweb',
            vuln_type='VulnerabilityWeb',
            parent_id=service.id,
            parent_type='Service',
            refs=[],
            policyviolations=[],
            description='helloworld',
            severity='low',
        )
        ws_name = host_with_hostnames.workspace.name
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name), data=raw_data)
        assert res.status_code == 201
        res = test_client.post('/v2/ws/{0}/vulns/'.format(ws_name),
                               data=raw_data)
        assert res.status_code == 409