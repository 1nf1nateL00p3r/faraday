import pytest
from server.models import (
    Reference,
    ReferenceVulnerabilityAssociation
)

def test_standard_host_vuln_hostnames(vulnerability_factory,
                                      host_with_hostnames,
                                      session):
    vuln = vulnerability_factory.create(host=host_with_hostnames,
                                        service=None)
    session.commit()
    assert set(vuln.hostnames) == set(host_with_hostnames.hostnames)

def test_standard_vuln_service_hostnames(vulnerability_factory,
                                         service_factory,
                                         host_with_hostnames,
                                         session):
    service = service_factory.create(host=host_with_hostnames)
    vuln = vulnerability_factory.create(service=service, host=None)
    session.commit()
    assert set(vuln.hostnames) == set(host_with_hostnames.hostnames)

def test_web_vuln_hostnames(vulnerability_web_factory,
                            service_factory,
                            host_with_hostnames,
                            session):
    service = service_factory.create(host=host_with_hostnames)
    vuln = vulnerability_web_factory.create(service=service)
    session.commit()
    assert set(vuln.hostnames) == set(host_with_hostnames.hostnames)

def test_code_vuln(vulnerability_code, session):
    session.commit()
    # Source code vulnerabilities have no hostnames
    assert vulnerability_code.hostnames == []


class TestReferences:
    @pytest.fixture(autouse=True)
    def load_data(self, vulnerability_factory, session):
        self.vuln = vulnerability_factory.create()
        self.vuln2 = vulnerability_factory.create(
            workspace=self.vuln.workspace)
        self.vuln_different_ws = vulnerability_factory.create()
        self.vulns = [self.vuln, self.vuln2, self.vuln_different_ws]
        session.commit()
        assert self.vuln.workspace_id != self.vuln_different_ws.workspace_id

    @pytest.fixture
    def reference(self, session):
        reference = Reference('CVE-2017-1234', self.vuln.workspace_id)
        session.add(reference)
        session.commit()
        return reference

    def test_empty_references(self):
        for vuln in self.vulns:
            assert isinstance(vuln.reference_instances, set)
            assert len(vuln.references) == 0

    def test_add_references(self, session):
        self.vuln.references.add('CVE-2017-1234')
        assert session.new
        session.commit()
        assert Reference.query.count() == 1
        ref = Reference.query.first()
        assert ref.name == 'CVE-2017-1234'
        assert ref.workspace_id == self.vuln.workspace_id

        # Re-adding the reference shouldn't do nothing
        self.vuln.references.add('CVE-2017-1234')
        assert Reference.query.count() == 1

    def test_add_existing_reference(self, session, reference):
        for vuln in [self.vuln, self.vuln2]:
            vuln.references.add('CVE-2017-1234')
            session.commit()
            assert Reference.query.count() == 1
            assert len(vuln.references) == 1
            assert vuln.reference_instances.pop().id == reference.id

    @pytest.mark.parametrize('orphan_vuln', [True, False],
                             ids=['with_orphan_reference',
                                  'with_used_reference'])
    def test_add_existing_from_other_workspace(self, session, reference,
                                               orphan_vuln):
        if not orphan_vuln:
            self.vuln.references.add(reference.name)
            session.commit()
        self.vuln_different_ws.references.add(reference.name)
        session.commit()
        assert Reference.query.count() == 2
        assert len(self.vuln_different_ws.references) == 1
        new_reference = self.vuln_different_ws.reference_instances.pop()
        assert (new_reference.workspace_id ==
                self.vuln_different_ws.workspace_id)
        assert new_reference.id != reference.id

    def test_remove_reference(self, session, reference):
        self.vuln.references.add(reference.name)
        session.commit()
        self.vuln.references.remove(reference.name)
        session.commit()
        assert ReferenceVulnerabilityAssociation.query.filter_by(
            vulnerability=self.vuln,
            reference=reference
        ).count() == 0

    @pytest.mark.skip('not implemented yet')
    def test_removes_orphan(self):
        pass

    @pytest.mark.parametrize('previous_refs,new_refs',[
        (set(), set()),
        (set(), {'CVE-2017-1234'}),
        ({'CVE-2017-1234'}, set()),
        ({'CVE-2017-1234'}, {'CVE-2017-1234'}),
        ({'CVE-2017-1234'}, {'CVE-2017-4321'}),
        ({'CVE-2017-1234'}, {'CVE-2017-1234', 'CVE-2017-4321'}),
    ], ids=[
        '{} -> {}',
        '{} -> {a}',
        '{a} -> {}',
        '{a} -> {a}',
        '{a} -> {b}',
        '{a} -> {a, b}',
    ])
    def test_direct_assignation(self, session, previous_refs, new_refs):
        for ref in previous_refs:
            self.vuln.references.add(ref)
        session.commit()
        self.vuln.references = new_refs
        session.commit()
        session.refresh(self.vuln)
        assert self.vuln.references == new_refs

    def test_create_workspace_and_vuln_with_refs(
            self, session, vulnerability_factory, reference):
        # This sould raise an error since the workspace_id won't be propagated
        # to the references
        vuln = vulnerability_factory.create()
        with pytest.raises(AssertionError):
            vuln.references = {'CVE-2017-1234'}

    def test_create_vuln_with_refs(self, session, vulnerability_factory):
        vuln = vulnerability_factory.build()
        session.add(vuln.workspace)
        session.commit()
        assert vuln.workspace.id
        vuln.references = {'CVE-2017-1234'}
        session.add(vuln)
        session.commit()
        assert len(vuln.references) == 1
        assert Reference.query.count() == 1
